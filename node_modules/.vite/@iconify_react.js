import {
  require_react
} from "./chunk-VD7M3R6Y.js";
import {
  __commonJS
} from "./chunk-KHGO2BKN.js";

// node_modules/@iconify/react/dist/icon.js
var require_icon = __commonJS((exports) => {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = exports.InlineIcon = exports.Icon = void 0;
  var _react = _interopRequireDefault(require_react());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function _typeof2(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof = function _typeof2(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof(obj);
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    return Constructor;
  }
  var idCounter = 0;
  var unitsSplit = /(-?[0-9.]*[0-9]+[0-9.]*)/g;
  var unitsTest = /^-?[0-9.]*[0-9]+[0-9.]*$/g;
  var iconAttributes = ["width", "height", "inline", "hFlip", "vFlip", "flip", "rotate", "align", "color", "box"];
  var defaultAttributes = {
    left: 0,
    top: 0,
    width: 16,
    height: 16,
    rotate: 0,
    hFlip: false,
    vFlip: false
  };
  function normalize(data) {
    var item = Object.create(null);
    var key;
    for (key in defaultAttributes) {
      item[key] = defaultAttributes[key];
    }
    for (key in data) {
      item[key] = data[key];
    }
    if (item.inlineTop === void 0) {
      item.inlineTop = item.top;
    }
    if (item.inlineHeight === void 0) {
      item.inlineHeight = item.height;
    }
    if (item.verticalAlign === void 0) {
      item.verticalAlign = item.height % 7 === 0 && item.height % 8 !== 0 ? -0.143 : -0.125;
    }
    return item;
  }
  function getAlignment(align) {
    var result;
    switch (align.horizontal) {
      case "left":
        result = "xMin";
        break;
      case "right":
        result = "xMax";
        break;
      default:
        result = "xMid";
    }
    switch (align.vertical) {
      case "top":
        result += "YMin";
        break;
      case "bottom":
        result += "YMax";
        break;
      default:
        result += "YMid";
    }
    result += align.slice ? " slice" : " meet";
    return result;
  }
  var SVG = function() {
    function SVG2(icon) {
      _classCallCheck(this, SVG2);
      this._item = icon;
    }
    _createClass(SVG2, [{
      key: "getAttributes",
      value: function getAttributes(props) {
        var item = this._item;
        if (_typeof(props) !== "object") {
          props = Object.create(null);
        }
        var align = {
          horizontal: "center",
          vertical: "middle",
          slice: false
        };
        var transform = {
          rotate: item.rotate,
          hFlip: item.hFlip,
          vFlip: item.vFlip
        };
        var style = Object.create(null);
        var attributes = Object.create(null);
        var inline = props.inline === true || props.inline === "true" || props.inline === "1";
        var box = {
          left: item.left,
          top: inline ? item.inlineTop : item.top,
          width: item.width,
          height: inline ? item.inlineHeight : item.height
        };
        ["hFlip", "vFlip"].forEach(function(key) {
          if (props[key] !== void 0 && (props[key] === true || props[key] === "true" || props[key] === "1")) {
            transform[key] = !transform[key];
          }
        });
        if (props.flip !== void 0) {
          props.flip.toLowerCase().split(/[\s,]+/).forEach(function(value2) {
            switch (value2) {
              case "horizontal":
                transform.hFlip = !transform.hFlip;
                break;
              case "vertical":
                transform.vFlip = !transform.vFlip;
            }
          });
        }
        if (props.rotate !== void 0) {
          var value = props.rotate;
          if (typeof value === "number") {
            transform.rotate += value;
          } else if (typeof value === "string") {
            var units = value.replace(/^-?[0-9.]*/, "");
            if (units === "") {
              value = parseInt(value);
              if (!isNaN(value)) {
                transform.rotate += value;
              }
            } else if (units !== value) {
              var split = false;
              switch (units) {
                case "%":
                  split = 25;
                  break;
                case "deg":
                  split = 90;
              }
              if (split) {
                value = parseInt(value.slice(0, value.length - units.length));
                if (!isNaN(value)) {
                  transform.rotate += Math.round(value / split);
                }
              }
            }
          }
        }
        var transformations = [], tempValue;
        if (transform.hFlip) {
          if (transform.vFlip) {
            transform.rotate += 2;
          } else {
            transformations.push("translate(" + (box.width + box.left) + " " + (0 - box.top) + ")");
            transformations.push("scale(-1 1)");
            box.top = box.left = 0;
          }
        } else if (transform.vFlip) {
          transformations.push("translate(" + (0 - box.left) + " " + (box.height + box.top) + ")");
          transformations.push("scale(1 -1)");
          box.top = box.left = 0;
        }
        switch (transform.rotate % 4) {
          case 1:
            tempValue = box.height / 2 + box.top;
            transformations.unshift("rotate(90 " + tempValue + " " + tempValue + ")");
            if (box.left !== 0 || box.top !== 0) {
              tempValue = box.left;
              box.left = box.top;
              box.top = tempValue;
            }
            if (box.width !== box.height) {
              tempValue = box.width;
              box.width = box.height;
              box.height = tempValue;
            }
            break;
          case 2:
            transformations.unshift("rotate(180 " + (box.width / 2 + box.left) + " " + (box.height / 2 + box.top) + ")");
            break;
          case 3:
            tempValue = box.width / 2 + box.left;
            transformations.unshift("rotate(-90 " + tempValue + " " + tempValue + ")");
            if (box.left !== 0 || box.top !== 0) {
              tempValue = box.left;
              box.left = box.top;
              box.top = tempValue;
            }
            if (box.width !== box.height) {
              tempValue = box.width;
              box.width = box.height;
              box.height = tempValue;
            }
            break;
        }
        var customWidth = props.width ? props.width : null;
        var customHeight = props.height ? props.height : null;
        var width, height;
        if (customWidth === null && customHeight === null) {
          customHeight = "1em";
        }
        if (customWidth !== null && customHeight !== null) {
          width = customWidth;
          height = customHeight;
        } else if (customWidth !== null) {
          width = customWidth;
          height = SVG2.calculateDimension(width, box.height / box.width);
        } else {
          height = customHeight;
          width = SVG2.calculateDimension(height, box.width / box.height);
        }
        if (width !== false) {
          attributes.width = width === "auto" ? box.width : width;
        }
        if (height !== false) {
          attributes.height = height === "auto" ? box.height : height;
        }
        if (inline && item.verticalAlign !== 0) {
          style["vertical-align"] = item.verticalAlign + "em";
        }
        if (props.align !== void 0) {
          props.align.toLowerCase().split(/[\s,]+/).forEach(function(value2) {
            switch (value2) {
              case "left":
              case "right":
              case "center":
                align.horizontal = value2;
                break;
              case "top":
              case "bottom":
              case "middle":
                align.vertical = value2;
                break;
              case "crop":
                align.slice = true;
                break;
              case "meet":
                align.slice = false;
            }
          });
        }
        attributes.preserveAspectRatio = getAlignment(align);
        attributes.viewBox = box.left + " " + box.top + " " + box.width + " " + box.height;
        var body = SVG2.replaceIDs(item.body);
        if (props.color !== void 0) {
          body = body.replace(/currentColor/g, props.color);
        }
        if (transformations.length) {
          body = '<g transform="' + transformations.join(" ") + '">' + body + "</g>";
        }
        if (props.box === true || props.box === "true" || props.box === "1") {
          body += '<rect x="' + box.left + '" y="' + box.top + '" width="' + box.width + '" height="' + box.height + '" fill="rgba(0, 0, 0, 0)" />';
        }
        return {
          attributes,
          body,
          style
        };
      }
    }, {
      key: "getSVG",
      value: function getSVG(props, addExtra) {
        var attributes = SVG2.splitAttributes(props), data = this.getAttributes(attributes.icon);
        var svg = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"';
        if (addExtra) {
          Object.keys(attributes.node).forEach(function(attr) {
            svg += " " + attr + '="' + attributes.node[attr] + '"';
          });
        }
        Object.keys(data.attributes).forEach(function(attr) {
          svg += " " + attr + '="' + data.attributes[attr] + '"';
        });
        svg += ' style="-ms-transform: rotate(360deg); -webkit-transform: rotate(360deg); transform: rotate(360deg);';
        Object.keys(data.style).forEach(function(attr) {
          svg += " " + attr + ": " + data.style[attr] + ";";
        });
        if (props && props.style !== void 0) {
          svg += props.style;
        }
        svg += '">';
        svg += data.body + "</svg>";
        return svg;
      }
    }], [{
      key: "splitAttributes",
      value: function splitAttributes(props) {
        var result = {
          icon: Object.create(null),
          node: Object.create(null)
        };
        Object.keys(props).forEach(function(name) {
          result[iconAttributes.indexOf(name) === -1 ? "node" : "icon"][name] = props[name];
        });
        return result;
      }
    }, {
      key: "calculateDimension",
      value: function calculateDimension(size, ratio, precision) {
        if (ratio === 1) {
          return size;
        }
        precision = precision === void 0 ? 100 : precision;
        if (typeof size === "number") {
          return Math.ceil(size * ratio * precision) / precision;
        }
        var split = size.split(unitsSplit);
        if (split === null || !split.length) {
          return null;
        }
        var results = [], code = split.shift(), isNumber = unitsTest.test(code), num;
        while (true) {
          if (isNumber) {
            num = parseFloat(code);
            if (isNaN(num)) {
              results.push(code);
            } else {
              results.push(Math.ceil(num * ratio * precision) / precision);
            }
          } else {
            results.push(code);
          }
          code = split.shift();
          if (code === void 0) {
            return results.join("");
          }
          isNumber = !isNumber;
        }
      }
    }, {
      key: "replaceIDs",
      value: function replaceIDs(body) {
        var regex = /\sid="(\S+)"/g, ids = [], match, prefix;
        function strReplace(search, replace, subject) {
          var pos = 0;
          while ((pos = subject.indexOf(search, pos)) !== -1) {
            subject = subject.slice(0, pos) + replace + subject.slice(pos + search.length);
            pos += replace.length;
          }
          return subject;
        }
        while (match = regex.exec(body)) {
          ids.push(match[1]);
        }
        if (!ids.length) {
          return body;
        }
        prefix = "IconifyId-" + Date.now().toString(16) + "-" + (Math.random() * 16777216 | 0).toString(16) + "-";
        ids.forEach(function(id) {
          var newID = prefix + idCounter;
          idCounter++;
          body = strReplace('="' + id + '"', '="' + newID + '"', body);
          body = strReplace('="#' + id + '"', '="#' + newID + '"', body);
          body = strReplace("(#" + id + ")", "(#" + newID + ")", body);
        });
        return body;
      }
    }]);
    return SVG2;
  }();
  function component(props, inline) {
    if (_typeof(props.icon) !== "object") {
      return null;
    }
    var split = SVG.splitAttributes(props), iconProps = split.icon, customAttributes = split.node;
    delete customAttributes.icon;
    if (iconProps.inline === void 0) {
      iconProps.inline = inline;
    }
    var svg = new SVG(normalize(props.icon));
    var iconData = svg.getAttributes(iconProps);
    var style = {
      transform: "rotate(360deg)"
    };
    if (iconData.style["vertical-align"] !== void 0) {
      style.verticalAlign = iconData.style["vertical-align"];
    }
    if (props.style !== void 0) {
      for (var _key in props.style) {
        style[_key] = props.style[_key];
      }
    }
    var attributes = {
      xmlns: "http://www.w3.org/2000/svg",
      focusable: false,
      style
    };
    var key;
    for (key in customAttributes) {
      attributes[key] = customAttributes[key];
    }
    for (key in iconData.attributes) {
      attributes[key] = iconData.attributes[key];
    }
    attributes.dangerouslySetInnerHTML = {
      __html: iconData.body
    };
    return _react["default"].createElement("svg", attributes, null);
  }
  var Icon = function Icon2(props) {
    return component(props, false);
  };
  exports.Icon = Icon;
  var InlineIcon = function InlineIcon2(props) {
    return component(props, true);
  };
  exports.InlineIcon = InlineIcon;
  var _default = Icon;
  exports["default"] = _default;
});

// dep:@iconify_react
var iconify_react_default = require_icon();
export {
  iconify_react_default as default
};
//# sourceMappingURL=@iconify_react.js.map
